hessian.objective_osc_HD <- function(par, theta, data, mesh, L, A, W, Aobs, order.HD, method="biased"){
    ## input:
    ##        par: named list containing vector of parameters X and scalar parameter beta
    ##        theta: fixed hyperprior parameters!! (revisit selection)
    ##        data: list of Y and Ypos (list(Y, Ypos))
    ##              - Y: data matrix of firing events
    ##              - Ypos: data matrix of positional data
    ##        mesh: Delaunay triangulation of spatial domain
    ##              constructed using inla.mesh.2d from INLA package
    ##        L: vector of areas of line segments used for 
    ##           the approximation of the integral of the
    ##           void probability. 
    ##        A: matrix of basis functions (psi_k(s_i))_{ik} evaluated        
    ##          at midpoints of line segments overline{s}_i
    ##        Aobs: matrix of basis functions (psi_k(s_i))_{ik}
    ##              evaluated at observed points s_i
    ## output:
    ##         hessian matrix of posterior log density of (X, beta) | (theta, Y)
    X         <- Matrix(par$X, ncol=1)
    n         <- nrow(data$Y)
    p         <- nrow(X)
    one.n     <- Matrix(rep(1, n), ncol=1)
    one.p     <- Matrix(rep(1, p), ncol=1)        
    expx      <- Matrix(exp(X))
    beta      <- Matrix(par$beta, ncol=1)
    Q.Omega   <- osc.precision(theta=theta[1:3], mesh=mesh)
    Q.HD      <- hd.precision(theta=theta[4:5], order=order.HD)
    Q.X       <- Q.HD%x%Q.Omega
    Q.beta    <- Diagonal(length(beta), 1e-6) 
    hess.X    <- Matrix(0, nrow=p, ncol=p)
    ## QU: is it possible to compute the hessian faster?
    ## options:
    ## 1) matrix algebra?
    ## 2) [X] C++ code: roughly 9 times faster than R code
    ## for(i in 1:(p-1))
    ##     for(j in i:p){
    ##         hess.X[i,j] <- -as.numeric(exp(beta))*(t(A[,i]*A[,j]*L)) %*% expAx
    ##     }   
    ## hess.X   <- Matrix::forceSymmetric(hess.X, uplo="U")

    hess.beta  <- Matrix(0, nrow=length(beta), ncol=length(beta))
    hess.Xbeta <- Matrix(0, nrow=length(X), ncol=length(beta))
    hess.X     <- Matrix(-as.numeric(exp(beta))*Diagonal(x=as.numeric((W*expx))))
    ## --------------------------------------------------
    hess.beta  <- -as.numeric(exp(beta))*(t(W)%*%expx) 
    ## 
    hess.Xbeta <- Matrix( -as.numeric(exp(beta))*as.numeric(W*expx) )
    ## 
    out <- Matrix::forceSymmetric(rBind( cBind(-hess.X + Q.X, -hess.Xbeta), cBind(-t(hess.Xbeta), -hess.beta + Q.beta) ))
    ## hessian_diag_and_upper_triangle(beta=as.numeric(beta), p,
    ##                                 L=as.matrix(L), A=as.matrix(A),
        ##                                 expAx=as.matrix(expAx))

    ## in Rcpp dense matrices of type dgeMatrix from Matrix package
    ## are not supported yet hess.X <- hess.X + t(hess.X) -
    ## 
    ## 
    return(out)
}


if(FALSE){
    hessianX.objective <- function(par, theta, spde, data, mesh, L, A, Aobs)
        ## input:
        ##        par: named list containing vector of parameters X and scalar parameter beta
        ##        theta: fixed hyperprior parameters!! (revisit selection)
        ##        spde: a model object for a Matern Gaussian model created with inla.spde2
        ##              using a PC prior for the parameters.        
        ##        data: list of Y and Ypos (list(Y, Ypos))
        ##              - Y: data matrix of firing events
        ##              - Ypos: data matrix of positional data
        ##        mesh: Delaunay triangulation of spatial domain
        ##              constructed using inla.mesh.2d from INLA package
        ##        L: vector of areas of line segments used for 
        ##           the approximation of the integral of the
        ##           void probability. 
        ##        A: matrix of basis functions (psi_k(s_i))_{ik} evaluated        
        ##          at midpoints of line segments overline{s}_i
        ##        Aobs: matrix of basis functions (psi_k(s_i))_{ik}
        ##              evaluated at observed points s_i
        ## output:
        ##         hessian matrix of posterior log density of X,beta | mid theta, Y. 
    {
        X         <- Matrix(par$X, ncol=1)
        n         <- nrow(data$Y)
        p         <- nrow(X)
        one.n     <- Matrix(rep(1, n), ncol=1)
        one.p     <- Matrix(rep(1, p), ncol=1)        
        beta      <- Matrix(par$beta, ncol=1)
        Q.X       <- inla.spde.precision(spde, theta=log(theta))
        Q.beta    <- Diagonal(length(beta), 1e-6) 
        hess.X    <- Matrix(0, nrow=p, ncol=p)
        ## QU: is it possible to compute the hessian faster?
        ## options:
        ## 1) matrix algebra?
        ## 2) [X] C++ code: roughly 9 times faster than R code
        ## for(i in 1:(p-1))
        ##     for(j in i:p){
        ##         hess.X[i,j] <- -as.numeric(exp(beta))*(t(A[,i]*A[,j]*L)) %*% expAx
        ##     }   
        ## hess.X   <- Matrix::forceSymmetric(hess.X, uplo="U")
        hess.X <- hessian_diag_and_upper_triangle(beta=as.numeric(beta), p,
                                                  L=as.matrix(L), A=as.matrix(A),
                                                  expAx=as.matrix(expAx))
        hess.X <- Matrix::forceSymmetric(hess.X, uplo="U")
        ## in Rcpp dense matrices of type dgeMatrix from Matrix package
        ## are not supported yet hess.X <- hess.X + t(hess.X) -
        ## hess.beta  <- Matrix(0,nrow=length(beta),
        ##                      ncol=length(beta))
        ## hess.Xbeta <- Matrix(0,nrow=length(X),
        ##                      ncol=length(beta))
        ## --------------------------------------------------
        ## hess.beta  <- Matrix(-as.numeric(exp(beta))*(t(L)%*%expAx))
        ## ## 
        ## hess.Xbeta <- Matrix(-as.numeric(exp(beta))*(t((L%*%t(one.p))*A) %*% expAx))
        ## 
        ## 
        ## out <- rBind(cBind(-hess.X + Q.X, -hess.Xbeta),
        ##              cBind(-t(hess.Xbeta), -hess.beta + Q.beta))
        out <- -hess.X + Q.X
        return(out)
    }
}
