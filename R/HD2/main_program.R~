#!/usr/bin/env Rscript
## data.path<-"/home/ipapasta/Software/R/grid_fields/R/data/Simulated_data/simulated_cn_same_30var_v_grid5trials7_simulated/"
if (length(args)==0) {
    stop("At least one argument must be supplied (input data.path).n", call.=FALSE)
} 
args = commandArgs(trailingOnly=TRUE)

## ROXYGENIZE
## 
fit_lgcp.osc_HD <- function(data.path, mesh.load=TRUE){
    print(paste(as.numeric(args[2])))
    source("Functions.R")    
    options(warn=-1)                        
    set.seed(111086) 
    counter <<- 0
    session.data       <- paste0(data.path, "session.csv")
    firing_events.data <- paste0(data.path, "1_firing_events.csv")
    mesh.data          <- paste0(data.path, "mesh.RData")
    ## data
    X <- read.csv(session.data, stringsAsFactors=FALSE)
    Y <- read.csv(firing_events.data, stringsAsFactors=FALSE)
    X <- X %>% mutate(hd =  (hd + 180)*(pi/180))
    Y <- Y %>% mutate(hd =  (hd + 180)*(pi/180))
    ## source code
    ## mesh
    if(mesh.load){
        load(mesh.data)
        p <- mesh$n
    }
    if(1-mesh.load){ 
        k <- 1.6
        mesh <- inla.mesh.2d(mycoords, max.edge=c(k, 25*k), offset=c(0.03, 120), cutoff=k/2)
    }
    Ypos.tmp <- data.frame(hd=X$hd, time=X$synced_time,
        coords=I(lapply(as.list(apply(cbind(X$position_x, X$position_y),1, as.list)), unlist))) %>%
        mutate(coords.lead = lead(coords)) %>%
        mutate(time.lead = lead(time)) %>%
        mutate(hd.lead = lead(hd)) %>%
        head(-1) #can we do better than this?
    ## 
    line.segments <- split.lines(mesh, sp=do.call("rbind", Ypos.tmp$coords), filter.zero.length=FALSE,
                                 ep=do.call("rbind",Ypos.tmp$coords.lead), tol=.0)
    df <- data.frame(origin=line.segments$split.origin,
                     filter.index=line.segments$filter.index,
                     sp=I(lapply(as.list(apply(line.segments$sp, 1, as.list)), unlist)),
                     ep=I(lapply(as.list(apply(line.segments$ep, 1, as.list)), unlist))) %>%
        group_by(origin) %>%
        summarize(sp=list(sp), ep=list(ep), filter.index=list(filter.index)) %>%
        mutate(sp = lapply(sp, function(x) do.call("rbind", x))) %>%
        mutate(ep = lapply(ep, function(x) do.call("rbind", x))) 
    interpolate <- function(x, y, z){
        interp <- (x) + (cumsum((z)/sum((z))))*((y) - (x))
        Delta <- diff(c(x, interp))
        attr(Delta, "data") <- c(x, interp[-length(interp)]) # note that
                                        # this way
                                        # the last
                                        # value from
                                        # the
                                        # combined
                                        # data vector
                                        # will be
                                        # missing so
                                        # needs to be
                                        # appended later
        return(Delta)
    }
    Ypos <- inner_join(Ypos.tmp %>% mutate(origin=1:nrow(Ypos.tmp)), df) %>%
        mutate(Li = map2(sp, ep, function(x, y) apply(y-x, 1, function(z) sqrt(sum(z^2))))) %>% #!!! 
        mutate(Ti = pmap(list(time, time.lead, Li), interpolate)) %>%
        mutate(HDi = pmap(list(hd, hd.lead, Li), interpolate )) 

    filter.index  <- do.call("c", Ypos$filter.index)
    intermediate.knots <- cbind(do.call("rbind",Ypos$sp)[filter.index,1][-1] -
                                do.call("rbind",Ypos$ep)[filter.index,1][-sum(filter.index)])
    functions.multiplicity <- intermediate.knots
    for(i in 1:length(functions.multiplicity)) {
        if(i==1){
            if(functions.multiplicity[i]!=0) functions.multiplicity[i] <- 1
            else functions.multiplicity[i] <- 2
        }else{
            if(functions.multiplicity[i]!=0) {
                functions.multiplicity[i] <- 1
                functions.multiplicity[i-1] <- 1} else{
                                                    functions.multiplicity[i] <- 2
                                                }
        }
    }
    functions.multiplicity <- c(1, functions.multiplicity, 1)
    ## no filter
    coords.trap  <- rbind(do.call("rbind",Ypos$sp)[filter.index,], tail(do.call("rbind",Ypos$ep),1))
    HD.data      <- c(do.call("c", (Ypos %>% mutate(HD=lapply(HDi, function(x) attr(x, "data"))))$HD), tail(Ypos$hd.lead, 1))
    T.data       <- c(do.call("c", (Ypos %>% mutate(T=lapply(Ti, function(x) attr(x, "data"))))$T), tail(Ypos$time.lead, 1))
    proj.s  <- inla.mesh.projector(mesh, loc=coords.trap)
    s.psi   <- data.frame(proj.s$proj$bary)
    names(s.psi) <- c("psi.1", "psi.2", "psi.3")
    data <- list(Ypos=Ypos, Y=Y)
    order.HD <- 5
    Aosc.obs  <- inla.spde.make.A(mesh=mesh, loc=as.matrix(data$Y %>% dplyr:: select(position_x, position_y)))
    Aosc      <- proj.s$proj$A
    Ahd.obs   <- circular.make.A(data$Y$hd, order=order.HD)
    Ahd       <- circular.make.A(HD.data, order=order.HD)
    ## ---------------------------------------------------------------
    Aobs <- inla.row.kron(Ahd.obs, Aosc.obs)
    A    <- inla.row.kron(Ahd, Aosc)
    Delta.T  <- diff(T.data)
    Delta.HD <- diff(HD.data)
    Delta.s  <- c(diff(do.call("c", Ypos$Li)), 0) #append a 0 value (fix this with lead)         
    Delta.time <- c((diff(T.data)[1]/2), diff(T.data, 2)/tail(diff(T.data,1), -1), (tail(diff(T.data),1)/2))
    Delta.sHD <- c(sqrt(Delta.s^2 + Delta.HD^2), 0) #LVCF
    W     <- Delta.time*Delta.sHD
    tW    <- t(W)
    DW    <- Diagonal(length(W), W)
    logrhoL    <- log(10)
    logsigmaU  <- log(1) 
    alpha1     <- .001
    alpha2     <- .4
    logrho.HDL    <- log(10)
    logsigma.HDU  <- log(1) 
    alphaHD1      <- .001
    alphaHD2      <- 1e-6
    hyperpar      <- list(alpha1=alpha1, alpha2=alpha2, rhoL=exp(logrhoL), sigmaU=exp(logsigmaU), alphaHD1=alphaHD1, alphaHD2=alphaHD2,
                          rho.HDL=exp(logrho.HDL), sigma.HDU=exp(logsigma.HDU))        
    par.theta  <- c(log(30), log(.5), -1, log(pi/6), log(.5))
    ## par.theta <- c(log(args[2]), log(args[3]), args[4], log(args[5]), log(args[6]))
    Xest       <-   Xinit    <- Matrix(rep(0, dim(A)[2]), ncol=1)
    betaest       <-   betainit <- 0 ## nrow(Y)/
        ## sum((Ypos %>% mutate(speed.lead = lead(speed),
        ##                      dt=c(diff(time)[1], diff(time) ))  %>% head(-1) %>%
        ##      mutate(val=dt*((speed + speed.lead)/2)))$val)
    gradest       <- NULL
    Hessianest    <- NULL
    par=par.theta; fn = pthetapc.prop.marg.post_osc_HD; hyperpar=hyperpar; data=data; type="biased"
    X=Xinit; beta=betaest; mesh=mesh; A=A; W=W; DW=DW; Aobs=Aobs; tAobs=t(Aobs); tA=t(A); order.HD=order.HD; acc=1e-6
    print.verbose=TRUE; control=list(maxit=500)
    opt.theta <- optim(par=par.theta, fn = pthetapc.prop.marg.post_osc_HD, hyperpar=hyperpar, data=data, type="biased",
                       X=Xinit, beta=betaest, mesh=mesh, A=A, tA=tA, W=W, tW=tW, DW=DW, Aobs=Aobs, tAobs=tAobs, order.HD=order.HD, acc=1e-6,
                       print.verbose=TRUE, control=list(maxit=10000, trace=TRUE))
    ## opt.theta <- cobyla(x0=par.theta, fn = pthetapc.prop.marg.post_osc_HD, hyperpar=hyperpar, data=data, type="biased",
    ##                    X=Xinit, beta=betaest, mesh=mesh, A=A, tA=tA, W=W, tW=tW, DW=DW, Aobs=Aobs, tAobs=tAobs, order.HD=order.HD, acc=1e-6,
    ##                    print.verbose=TRUE, nl.info=TRUE)
    path.to.save <- paste0(data.path, "fitted_model.osc_HD.RData") #check 
    save(list=ls(), file=path.to.save)
}
## !! quilt.plot


fit_lgcp.osc_HD(data.path=args[1])
