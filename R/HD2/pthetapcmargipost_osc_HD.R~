## par.theta=log.par.theta; acc=1e-7
pthetapc.prop.marg.post_osc_HD<- function(par.theta, hyperpar, data, X, beta, mesh, L, A, Aobs,  acc=1e-7)
{
    ## input:
    ##        par.theta: add description
    ##        spde: a model object for a Matern Gaussian model created with inla.spde2
    ##              using a PC prior for the parameters.        
    ##        data: list of Y and Ypos (list(Y, Ypos))
    ##              - Y: data matrix of firing events
    ##              - Ypos: data matrix of positional data
    ##        X: vector of parameters X
    ##        beta: scalar parameter beta
    ##        mesh: Delaunay triangulation of spatial domain
    ##              constructed using inla.mesh.2d from INLA package
    ##        L: vector of areas of line segments used for 
    ##           the approximation of the integral of the
    ##           void probability. 
    ##        A: matrix of basis functions (psi_k(s_i))_{ik} evaluated        
    ##          at midpoints of line segments overline{s}_i
    ##        Aobs: matrix of basis functions (psi_k(s_i))_{ik}
    ##              evaluated at observed points s_i
    ## output:
    ##        Approximate posterior log density of theta given Y
    ##        up to proportionality. This function is 
    ##        optimized with the polytope method (Nelder-Mead)
    ## print("is state maintained?")
    ## cat("\n")
    ## print(X)
    ## cat("\n")
    par.theta   <- par.theta
    par         <- list(X=X,beta=beta)
    Xbeta       <- rBind(par$X, par$beta) ## starting value
    n.X         <- X %>% length
    ## n.beta      <- beta %>% length
    ## 
    ## ---------------------------------------
    ## Newton optimization
    ## ---------------------------------------
    ## starting values
    grad     <- grad.objective_osc(par, theta=par.theta, 
                                   data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% matrix(ncol=1)
    hess     <- Matrix(hessian.objective_osc(par, theta=par.theta,
                                             data=data, mesh=mesh, L=L, A=A, Aobs=Aobs), sparse=TRUE)
    fval.p   <- fval.c <- objective_osc(par=par, theta=par.theta,
                                        data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% as.numeric
    scaled.acc  <- (fval.c %>% abs %>% max(1)) * acc     
    tol.test    <- Inf
    ## uncomment to track progress of Newton algo
    ## d <- -Matrix::solve(hess, grad)
    ## d2 <- -grad
    ## !!!        
    ## 
    print(paste("tol.test is :", tol.test,
                "scaled.acc is:", scaled.acc))
    ## fdiff <- TRUE
    while(TRUE)    #!!!
    {
        Xbeta.p <- Xbeta
        alpha   <- 1
        fval.p  <- fval.c            
        par     <- list(X=Xbeta.p[1:n.X], beta=Xbeta.p[(n.X+1): (Xbeta.p %>% length)])
        ## 
        ## Newton move
        ## 
        grad  <- grad.objective_osc(par, theta=par.theta, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% Matrix(ncol=1)
        hess  <- Matrix(hessian.objective_osc(par, theta=par.theta, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs), sparse=TRUE)
        ## 
        d       <- -Matrix::solve(hess, grad)
        d2      <- -grad
        Xbeta   <- Xbeta.p + alpha * d            
        par     <- list(X=Xbeta[1:n.X], beta=Xbeta[(n.X+1): (Xbeta %>% length)])
        ## print(par$X)
        ## 
        fval.c  <- as.numeric(objective_osc(par=par, theta=par.theta, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
        ## uncomment to track progress of Newton algo
        print(paste("fval.c is:", fval.c))
        ## Xbeta   <- c(par$X, par$beta) - alpha * d
        print(paste("fval.c is larger than fval.p", (fval.c > fval.p)))
        if(FALSE){
            while(fval.c > fval.p){                
                alpha <- alpha/2
                ## d <- grad
                Xbeta   <- Xbeta.p + alpha * d2
                par     <- list(X=Xbeta[1:n.X], beta=Xbeta[(n.X+1):(Xbeta %>% length)])
                ## 
                fval.c  <- as.numeric(objective_osc(par=par, theta=par.theta, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
                ## 
                tmp <- (fval.c - fval.p)
                ## uncomment to track progress of Newton algo
                print(paste("alpha is:", alpha,", ",
                            "Fc-Fp is:", round(tmp,2)))
                print(paste("fval.c is:", fval.c))
                if(alpha <= 2^(-8))
                {
                    Xbeta <- Xbeta.p
                    par     <- list(X=Xbeta.p[1:n.X], beta=Xbeta.p[(n.X+1):(Xbeta.p %>% length)])
                    ## 
                    fval.c  <- as.numeric(objective_osc(par=par, theta=par.theta, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
                    ## uncomment to track progress of Newton algo
                    print(paste("STOP MOVING"))
                    break
                }
            }
        }
        scaled.acc <- (fval.c  %>% abs %>% max(1)) * acc
        tol.test   <- (grad^2) %>% sum %>% sqrt            
        print(paste("f eval is:", fval.c))
        print(paste("TT is:", round(tol.test,3),
                    "SA is:", round(scaled.acc,3)))
        print(paste("Fp is:", round(fval.p,3),
                    "Fc is:", round(fval.c),3))
        nmv <- (((Xbeta^2) %>% sum %>% sqrt) -
                ((Xbeta.p^2) %>% sum %>% sqrt)) %>% abs
        if(tol.test < scaled.acc | nmv < acc) break                    
    }
    print("EXIT while loop")
    cat("\n \n \n")
    counter <<- counter+1
    print(paste("counter is equal to:",counter))
    cat("\n \n \n ")               
    ## ---------------------------------------------------------
    ## ---------------------------------------------------------
    ## pp.llik(data=data, X=par$X, mesh=mesh,
    ##     L=L, beta=par$beta, Aobs=Aobs)
    ## spde  <- inla.spde2.pcmatern(mesh, alpha=3/2,
    ##                              prior.range=c(1e-2,0.05),
    ##                              prior.sigma=c(0.34,0.05))
    Lxbeta.given.thetay    <- (Matrix::Cholesky(hess) %>% (Matrix::expand))$L    
    detQxbeta.given.thetay <- 2*sum(diag(Lxbeta.given.thetay))
    lp.G     <- .5*log(detQxbeta.given.thetay)    
    lp.Xbeta <- prior.Xbeta_osc(X=par$X, beta=par$beta, theta=c(par.theta),  mesh=mesh)
    llik     <- pp.llik(data=data, X=par$X, mesh=mesh, L=L, beta=par$beta, A=A,  Aobs=Aobs)
    ## output
    Xest    <<- par$X
    ## print(Xbeta)
    betaest <<- par$beta
    gradest     <<- grad
    Hessianest  <<- hess
    print(paste("rho is:", par.theta[1], " sigma is:", par.theta[2], "phi is: ", par.theta[3]))
    lp.theta    <- prior.theta_osc(rho=exp(par.theta[1]), sigma=exp(par.theta[2]),
                                   rhoL=hyperpar$rhoL, sigmaU=hyperpar$sigmaU,
                                   alpha1=hyperpar$alpha1, alpha2=hyperpar$alpha2,
                                   lg=TRUE)
    obj <- as.numeric(-(lp.theta + lp.Xbeta + llik - lp.G))
    save(betaest, Xest, par.theta, gradest, Hessianest, obj, file = paste0("/data/ipapasta/Xbeta", counter, ".RData"))
    return(as.numeric(-(lp.theta + lp.Xbeta + llik - lp.G)))
}




if(FALSE){
    ## par.theta=log.par.theta; acc=1e-7
    pthetapc.prop.marg.post.DE <- function(par.theta, hyperpar, spde, data, Xvec, beta, mesh, L, A, Aobs,  acc=1e-7)
    {
        ## input:
        ##        par.theta: add description
        ##        spde: a model object for a Matern Gaussian model created with inla.spde2
        ##              using a PC prior for the parameters.        
        ##        data: list of Y and Ypos (list(Y, Ypos))
        ##              - Y: data matrix of firing events
        ##              - Ypos: data matrix of positional data
        ##        X: vector of parameters X
        ##        beta: scalar parameter beta
        ##        mesh: Delaunay triangulation of spatial domain
        ##              constructed using inla.mesh.2d from INLA package
        ##        L: vector of areas of line segments used for 
        ##           the approximation of the integral of the
        ##           void probability. 
        ##        A: matrix of basis functions (psi_k(s_i))_{ik} evaluated        
        ##          at midpoints of line segments overline{s}_i
        ##        Aobs: matrix of basis functions (psi_k(s_i))_{ik}
        ##              evaluated at observed points s_i
        ## output:
        ##        Approximate posterior of theta given Y
        ##        up to proportionality. This function is 
        ##        optimized with the polytope method (Nelder-Mead)
        ## print("is state maintained?")
        ## cat("\n")
        ## print(X)
        ## cat("\n")
        par.theta   <- exp(par.theta)
        par         <- list(X=Xvec,beta=beta)
        Xbeta       <- rBind(par$X, par$beta) ## starting value
        n.X         <- X %>% length
        ## n.beta      <- beta %>% length
        ## 
        ## ---------------------------------------
        ## Newton optimization
        ## ---------------------------------------
        ## starting values
        grad     <- grad.objective(par, theta=par.theta, spde = spde,
                                   data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% matrix(ncol=1)
        hess     <- Matrix(hessian.objective(par, theta=par.theta, spde=spde,
                                             data=data, mesh=mesh, L=L, A=A, Aobs=Aobs), sparse=TRUE)
        fval.p   <- fval.c <- objective(par=par, theta=par.theta, spde=spde,
                                        data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% as.numeric
        scaled.acc  <- (fval.c %>% abs %>% max(1)) * acc     
        tol.test    <- Inf
        ## uncomment to track progress of Newton algo
        ## d <- -Matrix::solve(hess, grad)
        ## d2 <- -grad
        ## !!!        
        ## 
        print(paste("tol.test is :", tol.test,
                    "scaled.acc is:", scaled.acc))
        ## fdiff <- TRUE
        while(TRUE)    #!!!
        {
            Xbeta.p <- Xbeta
            alpha   <- 1
            fval.p  <- fval.c            
            par     <- list(X=Xbeta.p[1:n.X], beta=Xbeta.p[(n.X+1): (Xbeta.p %>% length)])
            ## 
            ## Newton move
            ## 
            grad  <- grad.objective(par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% Matrix(ncol=1)
            hess  <- Matrix(hessian.objective(par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs), sparse=TRUE)
            ## 
            d       <- -Matrix::solve(hess, grad)
            d2      <- -grad
            Xbeta   <- Xbeta.p + alpha * d            
            par     <- list(X=Xbeta[1:n.X], beta=Xbeta[(n.X+1): (Xbeta %>% length)])
            ## print(par$X)
            ## 
            fval.c  <- as.numeric(objective(par=par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
            ## uncomment to track progress of Newton algo
            print(paste("fval.c is:", fval.c))
            ## Xbeta   <- c(par$X, par$beta) - alpha * d
            print(paste("fval.c is larger than fval.p", (fval.c > fval.p)))
            while(fval.c > fval.p)
            {                
                alpha <- alpha/2
                ## d <- grad
                Xbeta   <- Xbeta.p + alpha * d2
                par     <- list(X=Xbeta[1:n.X], beta=Xbeta[(n.X+1):(Xbeta %>% length)])
                ## 
                fval.c  <- as.numeric(objective(par=par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
                ## 
                tmp <- (fval.c - fval.p)
                ## uncomment to track progress of Newton algo
                print(paste("alpha is:", alpha,", ",
                            "Fc-Fp is:", round(tmp,2)))
                print(paste("fval.c is:", fval.c))
                if(alpha <= 2^(-8))
                {
                    Xbeta <- Xbeta.p
                    par     <- list(X=Xbeta.p[1:n.X], beta=Xbeta.p[(n.X+1):(Xbeta.p %>% length)])
                    ## 
                    fval.c  <- as.numeric(objective(par=par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
                    ## uncomment to track progress of Newton algo
                    print(paste("STOP MOVING"))
                    break
                }
            }
            scaled.acc <- (fval.c  %>% abs %>% max(1)) * acc
            tol.test   <- (grad^2) %>% sum %>% sqrt            
            print(paste("f eval is:", fval.c))
            print(paste("TT is:", round(tol.test,3),
                        "SA is:", round(scaled.acc,3)))
            print(paste("Fp is:", round(fval.p,3),
                        "Fc is:", round(fval.c),3))
            nmv <- (((Xbeta^2) %>% sum %>% sqrt) -
                    ((Xbeta.p^2) %>% sum %>% sqrt)) %>% abs
            if(tol.test < scaled.acc | nmv < acc)
            {

                break
            }
        }
        print("EXIT while loop")
        cat("\n \n \n")
        counter <<- counter+1
        print(paste0("counter is equal to: ",counter))
        cat("\n \n \n ")               
        ## ---------------------------------------------------------
        ## ---------------------------------------------------------
        ## pp.llik(data=data, X=par$X, mesh=mesh,
        ##     L=L, beta=par$beta, Aobs=Aobs)
        ## spde  <- inla.spde2.pcmatern(mesh, alpha=3/2,
        ##                              prior.range=c(1e-2,0.05),
        ##                              prior.sigma=c(0.34,0.05))
        Lxbeta.given.thetay    <- (Matrix::Cholesky(hess) %>% (Matrix::expand))$L    
        detQxbeta.given.thetay <- 2*sum(diag(Lxbeta.given.thetay))
        lp.G     <- .5*log(detQxbeta.given.thetay)    
        lp.Xbeta <- prior.Xbeta(X=par$X, beta=par$beta, spde=spde, theta=c(par.theta),  mesh=mesh)
        llik     <- pp.llik(data=data, X=par$X, mesh=mesh, L=L, beta=par$beta, A=A,  Aobs=Aobs)
        ## output
        Xest    <<- par$X
        ## print(Xbeta)
        betaest <<- par$beta
        gradest     <<- grad
        Hessianest  <<- hess
        print(paste("rho is:", par.theta[1], " sigma is:", par.theta[2]))
        lp.theta    <- prior.theta(par.theta[1], par.theta[2],
                                   rhoL=hyperpar$rhoL, sigmaU=hyperpar$sigmaU,
                                   alpha1=hyperpar$alpha1, alpha2=hyperpar$alpha2,
                                   lg=TRUE)
        return(as.numeric(-(lp.theta + lp.Xbeta + llik - lp.G)))
    }
}


if(FALSE){
    betaa <- seq(-1, 0.99, len=100)
    plot(betaa, (1-betaa)^(betaa/(1-betaa)), type="l")
    plot(betaa, 1/(1-betaa), type="l")    
}
