    ptheta.prop.marg.post <- function(par.theta, spde, data, X, beta, mesh, L, A, Aobs,  acc=1e-7)
    {
        ## input:
        ##        par.theta: add description
        ##        spde: a model object for a Matern Gaussian model created with inla.spde2
        ##              using a PC prior for the parameters.        
        ##        data: list of Y and Ypos (list(Y, Ypos))
        ##              - Y: data matrix of firing events
        ##              - Ypos: data matrix of positional data
        ##        X: vector of parameters X
        ##        beta: scalar parameter beta
        ##        mesh: Delaunay triangulation of spatial domain
        ##              constructed using inla.mesh.2d from INLA package
        ##        L: vector of areas of line segments used for 
        ##           the approximation of the integral of the
        ##           void probability. 
        ##        A: matrix of basis functions (psi_k(s_i))_{ik} evaluated        
        ##          at midpoints of line segments overline{s}_i
        ##        Aobs: matrix of basis functions (psi_k(s_i))_{ik}
        ##              evaluated at observed points s_i
        ## output:
        ##        Approximate posterior of theta given Y
        ##        up to proportionality. This function is 
        ##        optimized with the polytope method (Nelder-Mead)
        ## print("is state maintained?")
        ## cat("\n")
        ## print(X)
        ## cat("\n")
        par.theta   <- exp(par.theta)
        par         <- list(X=X,beta=beta)
        Xbeta       <- rBind(par$X, par$beta) ## starting value
        n.X         <- X %>% length
        ## n.beta      <- beta %>% length
        ## 
        ## ---------------------------------------
        ## Newton optimization
        ## ---------------------------------------
        ## starting values
        grad     <- grad.objective(par, theta=par.theta, spde = spde,
                                   data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% matrix(ncol=1)
        hess     <- Matrix(hessian.objective(par, theta=par.theta, spde=spde,
                                             data=data, mesh=mesh, L=L, A=A, Aobs=Aobs), sparse=TRUE)
        fval.p   <- fval.c <- objective(par=par, theta=par.theta, spde=spde,
                                        data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% as.numeric
        scaled.acc  <- (fval.c %>% abs %>% max(1)) * acc     
        tol.test    <- Inf
        ## uncomment to track progress of Newton algo
        ## d <- -Matrix::solve(hess, grad)
        ## d2 <- -grad
        ## !!!        
        ## 
        print(paste("tol.test is :", tol.test,
                    "scaled.acc is:", scaled.acc))
        ## fdiff <- TRUE
        while(TRUE)    #!!!
        {
            Xbeta.p <- Xbeta
            alpha   <- 1
            fval.p  <- fval.c            
            par     <- list(X=Xbeta.p[1:n.X], beta=Xbeta.p[(n.X+1): (Xbeta.p %>% length)])
            ## 
            ## Newton move
            ## 
            grad  <- grad.objective(par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs) %>% Matrix(ncol=1)
            hess  <- Matrix(hessian.objective(par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs), sparse=TRUE)
            ## 
            d       <- -Matrix::solve(hess, grad)
            d2      <- -grad
            Xbeta   <- Xbeta.p + alpha * d            
            par     <- list(X=Xbeta[1:n.X], beta=Xbeta[(n.X+1): (Xbeta %>% length)])
            ## 
            fval.c  <- as.numeric(objective(par=par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
            ## uncomment to track progress of Newton algo
            print(paste("fval.c is:", fval.c))
            ## Xbeta   <- c(par$X, par$beta) - alpha * d
            print(paste("fval.c is larger than fval.p", (fval.c > fval.p)))
            while(fval.c > fval.p)
            {                
                alpha <- alpha/2
                ## d <- grad
                Xbeta   <- Xbeta.p + alpha * d2
                par     <- list(X=Xbeta[1:n.X], beta=Xbeta[(n.X+1):(Xbeta %>% length)])
                ## 
                fval.c  <- as.numeric(objective(par=par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
                ## 
                tmp <- (fval.c - fval.p)
                ## uncomment to track progress of Newton algo
                print(paste("alpha is:", alpha,", ",
                            "Fc-Fp is:", round(tmp,2)))
                print(paste("fval.c is:", fval.c))
                if(alpha <= 2^(-8))
                {
                    Xbeta <- Xbeta.p
                    par     <- list(X=Xbeta.p[1:n.X], beta=Xbeta.p[(n.X+1):(Xbeta.p %>% length)])
                    ## 
                    fval.c  <- as.numeric(objective(par=par, theta=par.theta, spde=spde, data=data, mesh=mesh, L=L, A=A, Aobs=Aobs))
                    ## uncomment to track progress of Newton algo
                    print(paste("STOP MOVING"))
                    break
                }
            }
            scaled.acc <- (fval.c  %>% abs %>% max(1)) * acc
            tol.test   <- (grad^2) %>% sum %>% sqrt            
            print(paste("f eval is:", fval.c))
            print(paste("TT is:", round(tol.test,3),
                        "SA is:", round(scaled.acc,3)))
            print(paste("Fp is:", round(fval.p,3),
                        "Fc is:", round(fval.c),3))
            nmv <- (((Xbeta^2) %>% sum %>% sqrt) -
                    ((Xbeta.p^2) %>% sum %>% sqrt)) %>% abs
            if(tol.test < scaled.acc | nmv < acc)
            {

                break
            }
        }
        print("EXIT while loop")
        cat("\n \n \n")
        counter <<- counter+1
        print(paste("counter is equal to:",counter))
        cat("\n \n \n ")               
        ## ---------------------------------------------------------
        ## ---------------------------------------------------------
        ## pp.llik(data=data, X=par$X, mesh=mesh,
        ##     L=L, beta=par$beta, Aobs=Aobs)
        ## spde  <- inla.spde2.pcmatern(mesh, alpha=3/2,
        ##                              prior.range=c(1e-2,0.05),
        ##                              prior.sigma=c(0.34,0.05))
        Lxbeta.given.thetay    <- (Matrix::Cholesky(hess) %>% (Matrix::expand))$L    
        detQxbeta.given.thetay <- 2*sum(diag(Lxbeta.given.thetay))
        lp.G     <- .5*log(detQxbeta.given.thetay)    
        lp.Xbeta <- prior.Xbeta(X=par$X, beta=par$beta, spde=spde, theta=c(par.theta),  mesh=mesh)
        llik     <- pp.llik(data=data, X=par$X, mesh=mesh, L=L, beta=par$beta, A=A,  Aobs=Aobs)
        ## output
        Xest    <<- Matrix(par$X, ncol=1)
        betaest <<- Matrix(par$beta, ncol=1)
        gradest     <<- grad
        Hessianest  <<- hess
        return(as.numeric(-(lp.Xbeta + llik - lp.G)))
    }
