library(INLA)

osc.precision <- function(theta, mesh) {
  theta1 <- theta[1]
  theta2 <- theta[2]
  theta3 <- theta[3]
  rho <- exp(theta1)
  kappa <- sqrt(8) / rho
  sigma <- exp(theta2)
  phi <- (1 - exp(-theta3)) / (1 + exp(-theta3))
  sincpth <- sqrt(1 - phi^2) / acos(phi)
  tausq <- 1 / (4 * pi * (sigma^2) * (kappa^2) * sincpth)
  ## ---------------------------------------
  o <- inla.mesh.fem(mesh, order = 2)
  ##
  tausq * ((kappa^4) * (o$c0) + (2 * (kappa^2) * phi * (o$g1)) + o$g2)
  ##
}

plot.variances <- function(mesh, theta) {
  sigma <- exp(theta[2])
  QO    <- osc.precision(theta, mesh)
  dist  <- rowSums(mesh$loc^2)^0.5
  v     <- diag(inla.qinv(QO))
  rhor   <- round(exp(theta[1]), 3)
  sigmar <- round(exp(theta[2]), 3)
  phir   <- round((1-exp(-theta[3]))/(1+exp(-theta[3])), 3)
  plot(dist,
       v / sigma^2,
       ## ylim = c(0, max(1, max(v) / sigma^2)),
       main = paste("theta = ", c(rhor, sigmar, phir), collapse = ", ")
       ## xlim = c(0, 1)
       )
  abline(h = 1, lwd = 5)
  c(mean(v[dist < 150]), sigma^2)
}


mesh <- INLA::inla.mesh.2d(loc.domain = cbind(0, 0),
                           offset = c(1, 1),
                           n = c(16, 16),
                           max.edge = c(0.05, 0.5))

k <- 1.
mesh <- inla.mesh.2d(mycoords, max.edge=c(k, 25*k), offset=c(0.03, 120), cutoff=k/2)

k <- 1.
mesh <- inla.mesh.2d(Ysim, max.edge=c(k, 25*k), offset=c(0.03, 120), cutoff=k/2)

plot(mesh, asp=1)
variances <- matrix(0, 0, 5)

load("mesh_test.RData")

while (TRUE) {
    ## theta1  <- c(runif(1,2,5), )
    ## theta2  <- runif(1, log(.001), log(5))
    ## theta3  <- runif(1,-15,15)
    theta <- c(runif(1, log(5), log(100)),
               runif(1, log(.01), log(100)),
               runif(1, -15, 15))
    ## theta <- c(log(12),
    ##            log(103),
    ##            -15)
    variances <- rbind(variances,
                       c(theta, plot.variances(mesh, theta)))
    ## Sys.sleep(5)
                                        # oscillation control and variance ratios
    plot(variances[,3], variances[,4] / variances[,5])
}

df <- data.frame(variances)
names(df) <- c("theta1", "theta2", "theta3", "mean", "sigmasq")
df <- df %>% mutate(ratio=mean/sigmasq)
plot((1-exp(-variances[,3]))/(1+exp(-variances[,3])), variances[,4] / variances[,5])


plot(variances[,3], variances[,4] / variances[,5])
abline(v=-7)
plot_ly(df, x=~exp(theta1), y=~(1-exp(-theta3))/(1+exp(-theta3)), z=~ratio)

