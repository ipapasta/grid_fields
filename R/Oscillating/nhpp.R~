load("/home/ipapasta/Desktop/mle_oscillating_biased.RData")

Ypos     <- data$Ypos
Y        <- data$Y
Aobs     <- inla.spde.make.A(mesh=mesh, loc=Y %>% dplyr:: select(position_x, position_y) %>% as.matrix)
A        <- inla.spde.make.A(mesh=mesh, loc=as.matrix(do.call("rbind",Ypos$midpoints)))
L        <- Matrix(do.call("rbind", Ypos$midpoints.weights))
W        <- Matrix(t(t(L)%*%A))
## 
n        <- nrow(Y)
p        <- nrow(X)
tr.one.n <- matrix(rep(1, n), nrow=1)
tW       <- t(W)
EN       <- as.numeric(((tW%*%(exp(Xest))))*as.numeric(exp(betaest)))
as.numeric(EN) == nrow(Y)


## 
## max intensity over animal's trajectory
##

pos.coords <- data.frame(do.call("rbind", data$Ypos$coords))
names(pos.coords) <- c("x", "y")
N       <- 5000
maxx    <- max(pos.coords[,"x"]+30)
maxy    <- max(pos.coords[,"y"]+30)
minx    <- min(pos.coords[,"x"]-30)
miny    <- min(pos.coords[,"y"]-30)
coords  <- expand.grid(seq(minx, maxx, seq=N), seq(miny, maxy, seq=N))
one.vec <- matrix(rep(1, nrow(coords)), ncol=1)
Apred       <- inla.spde.make.A(mesh=mesh, loc=as.matrix(coords))
lambdapred  <- exp(matrix((as.numeric(betaest)*one.vec), ncol=1) + Apred%*%Xest)

max(lambdapred) 

## 
## Length of trajectory
##

dist.xy <- function(x,y){
    as.numeric(sqrt(sum((y-x)^2)))
}

df.trajectory <- Ypos %>% mutate(speed.lead = lead(speed), dt=c(synced_time[1], diff(synced_time) ))  %>%
    head(nrow(Ypos)-1) %>% 
    mutate(val=dt*((speed + speed.lead)/2)) %>%
    mutate(dist = map2(coords, lead, dist.xy))

absGamma <- sum(unlist(df.trajectory$dist))



## simulation from homogeneous point process
n.hpp <- absGamma*max(lambdapred)       # n points from 
p.hpp <- cumsum(rexp(n.hpp, max(lambdapred)))


## next need to map p.hpp on locations (x,y) of given trajectory 

counter <- 0
Ysim.hpp <- t(sapply(p.hpp, function(d, d.vec=cumsum(unlist(df.trajectory$dist)),
                                     coords=do.call("rbind",(df.trajectory$coords)),
                                     lead=do.call("rbind",(df.trajectory$lead))){
    ind         <- (max(which(d.vec <= d))) 
    start.point <- coords[ind,]
    dist.diff   <- (d - d.vec[ind])
    unit.vector <- (lead[ind,]-coords[ind,])/sqrt(sum((lead[ind,]-coords[ind,])^2))
    start.point + dist.diff*unit.vector
}))


Asim        <- inla.spde.make.A(mesh=mesh, loc=as.matrix(Ysim.hpp))
one.vec.sim <- matrix(rep(1, nrow(Ysim.hpp)), ncol=1)
lambdasim   <- exp(matrix((as.numeric(betaest)*one.vec.sim), ncol=1) + Asim%*%Xest)

U                <- runif(nrow(Ysim.hpp))
thinning.vector  <- U >= 1 - (lambdasim/max(lambdapred))

Ysim <- Ysim.hpp[which(thinning.vector), ]

Ysim <- as.data.frame(Ysim) %>% as_tibble
names(Ysim) <- c("position_x", "position_y")
save(Ysim, file="Ysim.RData")


x11()
par(mfrow=c(1,2))

## pdf(file="/home/ipapasta/Desktop/true_and_sim.pdf", height=8, width=11)
par(mfrow=c(1,2))
par(mar=c(1,1,1,1))
plot(trajectory)
points(mycoords, col=2, pch=16, cex=0.8)
## 
plot(trajectory)
points(Ysim, col=2, pch=16, cex=0.8)
## dev.off()


plot(trajectory)
points(Ysim.hpp, col=2, pch=16, cex=.7)
abline(v=-1.1)




indtest <- which(Ysim.hpp[,1]< 0.004)

p.test <- (function(d, d.vec=cumsum(unlist(df.trajectory$dist)),
                    coords=do.call("rbind",(df.trajectory$coords)),
                    lead=do.call("rbind",(df.trajectory$lead))){
    ind <- max(which(d.vec <= d))
    start.point <- coords[ind,]
    dist.diff   <- (d - d.vec[ind])
    unit.vector <- (lead[ind,]-coords[ind,])/sqrt(sum((lead[ind,]-coords[ind,])^2))
    ## counter <<- counter+1
    ## print(paste("Getting slower? ", counter))
    start.point + dist.diff*unit.vector
})(d=p.hpp[1])
