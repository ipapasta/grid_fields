* Hierarchical Poisson point process models for grid cells 
#+html: <p align="center"><img src="/R/animations/anim_space_direction.varying.direction.combined.gif" /></p>
** Brief code instructions
- load_data.R (do not print any object from this script in the console)
- spde.osc.temporal is the main script for manipulating data and
  fiting models M0, M1 and M2. Models M0 and M1 may be fit
  "reasonably" fast on a standard computer. Model M2 is
  computationally intensive.
- predictions_M0.M1.M2.R contains code for plotting fitted intensity functions for models M0, M1 and M2

** An illustrative example

*** Loading data
Load packages and helper functions, and set default options for optimization with =INLA=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  library(tidyverse)
  library(dplyr)
  library(purrr)
  library(sp)
  library(INLA)
  library(inlabru)
  bru_options_set(inla.mode = "experimental")
  ## option "experimental" implements Variational Bayes correction this
  ## is useful for Poisson point process likelihoods.
  ## This option is implemented in latest INLA testing version
  if(inla.pardiso.check() != "SUCCESS: PARDISO IS INSTALLED AND WORKING"){
    ## enable openmp for parallel computing using strategy "huge".
    ## this is going to engage all RAM and core resources of the
    ## computer needs some care when setting this up on Eddie.
    bru_options_set(control.compute = list(openmp.strategy="huge"))
  }else{
    bru_options_set(control.compute = list(openmp.strategy="pardiso"))
  }
  source("R/Functions.R")
#+end_src
We load the raw data (session id =M14_2018-05-16_11-29-05=, gridness score 0.913)
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  load(url("https://www.maths.ed.ac.uk/~ipapasta/mouse_data.RData"))
  ls()
#+end_src
The firing events are stored in data frame =Y= and the positional data in data frame =X=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  ##
  ## Firing events and trajectory 
  ## 
  mycoords     <- SpatialPoints(Y[,c("position_x", "position_y")])
  Pl           <- Polygon(cbind(X$position_x, X$position_y)); ID   <- "[0,1]x[0,1]"
  Pls          <- Polygons(list(Pl), ID=ID); SPls <- SpatialPolygons(list(Pls))
  trajectory   <- SpatialPolygonsDataFrame(SPls, data.frame(value=1, row.names=ID))
  ## 
#+end_src

#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  plot(trajectory)
  points(mycoords, col=2, pch=16, cex=0.5)
#+end_src

 #+begin_src R :results output latex :exports none :session *R:grid_fields* 
   ## svglite(file="R/animations/trajectory.svg", bg="transparent")
   svglite(file="R/animations/trajectory.svg", bg="white")
   ## 
   plot(trajectory)
   points(mycoords, col=2, pch=16, cex=0.5)
   dev.off()
#+end_src
#+html: <p align="center"><img src="/R/animations/trajectory.svg" /></p>

*** Spatial and circular meshes
Next we create a spatial and and a circular mesh. The parameter =k= in
the code below controls the resolution of the spatial mesh. Smaller
values for =k= yield finer spatial meshes. The spatial mesh is
constructed in such a way that the resolution is finer for regions
where we observe more spikes and coarser otherwise. Also, since
oscillating Gaussian random fields exhibit strong resonance effects,
it is important to triangulate the domain outside the arena where the
animal runs. The properties of the mesh in the region that is exterior
to the arena can be taken to coarser. For the circular mesh, we choose
a regular grid of of 29 vertices on the circle (the 30th is folded in
the 1st due to cyclicity in the construction below, see =mesh.hd$n=).
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
k           <- 5
mesh        <- inla.mesh.2d(loc=mycoords, max.edge=c(k, 25*k), offset=c(0.03, 120), cutoff=k/2)
p           <- mesh$n
p.theta     <- 30
theta.nodes <- seq(0, 2*pi, len=p.theta)
mesh.hd     <- inla.mesh.1d(theta.nodes, boundary="cyclic", degree=1)
#+end_src
We plot the spatial and circular meshes obtained from the code
above.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  plot(mesh, asp=1)
  x1 <- cos(mesh.hd$loc); y1 <- sin(mesh.hd$loc)
  plot(x1, y1, pch=16, asp=1, axes=FALSE, xlab="", ylab="", main="circular mesh")
  abline(h=0);  abline(v=0)
  text(-.05,1, paste("1")); text(1,-.05, paste("1"))
#+end_src
The constructions of the latent spatial and latent head-directional
effects are tightly linked to the design of the meshes. See Section (REF)

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  ## svglite(file="R/animations/trajectory.svg", bg="transparent")
  svglite(file="R/animations/meshes.svg", bg="white")
  ##
  par(mfrow=c(1,2))
  plot(mesh, asp=1)
  x1 <- cos(mesh.hd$loc); y1 <- sin(mesh.hd$loc)
  plot(x1, y1, pch=16, asp=1, axes=FALSE, xlab="", ylab="", main="circular mesh")
  abline(h=0);  abline(v=0)
  text(-.05,1, paste("1")); text(1,-.1, paste("1"))
  dev.off()
#+end_src
#+html: <p align="center"><img src="/R/animations/meshes.svg" /></p>


*** Boxing line segments
To facilitate a stable numerical integration for the integral in the
Poisson point process likelihood, all line segments from the
trajectory need to be further split so that each segment falls
precisely
- in one and only one triangle of the spatial mesh and;
- in one and only one arc out of the possible 29 arcs of the circular
  mesh.

The code below uses the wrapper function
=split.segments.wrapper.function=. Firstly, this function uses
=split.arcs= to split the path segments so that each new segment is
boxed by an arc on the circular mesh. Then, the function
=inlabru::split_lines= is used to split again the segments obtained
from of =split.arcs= so that every line segment is also boxed by a triangle. 
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  Ypos.ls        <- split.segments.wrapper.function(X=X, mesh=mesh, mesh.hd=mesh.hd)
  Ypos           <- Ypos.tmp.ls$Ypos
  filter.index   <- Ypos.tmp.ls$filter.index
  line.segments  <- Ypos.ls$line.segments
#+end_src
This output is stored in =Ypos= and the plots below illustrate the
effect of line splitting. The new line segments are plotted over a
subregion of the spatial domain on the left panel below. Each newly
derived line segment is given by the start and end of an arrow whilst
the raw segments by contiguous blue dots. Similarly for the head
direction on the right panel below, each newly derived line segment is
given by contiguous black circles whilst the raw segments by blue
dots. If an line segment was initially boxed by a triangle and by an
arc segment, then this line segment remains unchanged. When there is a
split, however, the values of the covariate (location, head direction
and time) are imputed with linear interpolation.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  par(mfrow=c(1,2))
  plot(mesh, xlim=c(46, 54), ylim=c(46,54), asp=1, main="")
  arrows(do.call("rbind", Ypos$sp)[,1], do.call("rbind", Ypos$sp)[,2], 
         do.call("rbind", Ypos$ep)[,1], do.call("rbind", Ypos$ep)[,2], col=2, lwd=1, length=0.05)
  points(X$position_x, X$position_y, col="blue", pch=16, cex=0.5)
  plot(Ypos$time[1:50,], Ypos$hd[1:50], type="b", cex=1, xlab="time", ylab="head direction")
  points(X$synced_time, X$hd, col="blue", cex=0.5, pch=16)
  abline(h = seq(0, 2*pi, len=30), lty=2, lwd=.5)
#+end_src

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  svglite(file="R/animations/line_splits.svg", bg="white")
  par(mfrow=c(1,2))
  plot(mesh, xlim=c(46, 54), ylim=c(46,54), asp=1, main="")
  arrows(do.call("rbind", Ypos$sp)[,1], do.call("rbind", Ypos$sp)[,2], 
         do.call("rbind", Ypos$ep)[,1], do.call("rbind", Ypos$ep)[,2], col=2, lwd=1, length=0.05)
  points(X$position_x, X$position_y, col="blue", pch=16, cex=0.5)
  plot(Ypos$time[1:50,], Ypos$hd[1:50], type="b", cex=1, xlab="time", ylab="head direction")
  points(X$synced_time, X$hd, col="blue", cex=0.5, pch=16)
  abline(h = seq(0, 2*pi, len=30), lty=2, lwd=.5)
  dev.off()
#+end_src
#+html: <p align="center"><img src="/R/animations/line_splits.svg" /></p>
Lastly, we save the covariate in objects =coords.trap=, =HD.data= and =T.data=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
coords.trap  <- rbind(do.call("rbind",Ypos$sp)[filter.index,], tail(do.call("rbind",Ypos$ep),1))
HD.data      <- c(do.call("c", (Ypos %>% mutate(HD=lapply(HDi, function(x) attr(x, "data"))))$HD), tail(Ypos$hd.lead, 1))
T.data       <- c(do.call("c", (Ypos %>% mutate(T=lapply(Ti, function(x) attr(x, "data"))))$T), tail(Ypos$time.lead, 1))
#+end_src

*** Temporal mesh
Additionally to the spatial and circular meshes, a temporal mesh is
also required when the effect of time on the variation of spikes is
included in models. The temporal mesh is constructed by thinning the
grid of times that are obtained from the newly derived line
segments. Below we choose the fixed value =100= for thinning so that,
if the consecutive times at the starting positions of the line segment
(obtained via splitting) are denoted by =t[1],t[2], ..=, then the
temporal mesh is taken as =t[1],t[300],t[600] ..=. With this
construction, each line segment is also boxed by contiguous time
points in the temporal mesh.
#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  coords.trap  <- rbind(do.call("rbind",Ypos$sp)[filter.index,], tail(do.call("rbind",Ypos$ep),1))
  HD.data      <- c(do.call("c", (Ypos %>% mutate(HD=lapply(HDi, function(x) attr(x, "data"))))$HD), tail(Ypos$hd.lead, 1))
  T.data       <- c(do.call("c", (Ypos %>% mutate(T=lapply(Ti, function(x) attr(x, "data"))))$T), tail(Ypos$time.lead, 1))
  mesh1d  <- inla.mesh.1d(loc=c(T.data[seq(1, length(T.data), by = 300)], T.data[length(T.data)]), order=2)
#+end_src

#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  par(mfrow=c(1,2))
  plot(trajectory)
  points(coords.trap[seq(1, length(T.data), by = 300), 1], coords.trap[seq(1, length(T.data), by = 300), 2], pch=4, col=2, cex=.8, asp=1)
  plot(mesh1d$loc[1:50], rep(0,50), pch=16, cex=0.6, xlab="time", ylab="", axes=FALSE); axis(1)
  abline(h=0)
#+end_src

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  svglite(file="R/animations/temporal_mesh.svg", bg="white")
  par(mfrow=c(1,2))
  plot(trajectory)
  points(coords.trap[seq(1, length(T.data), by = 300), 1], coords.trap[seq(1, length(T.data), by = 300), 2], pch=4, col=2, cex=.8, asp=1)
  plot(mesh1d$loc[1:50], rep(0,50), pch=16, cex=0.6, xlab="time", ylab="", axes=FALSE); axis(1)
  abline(h=0)
  dev.off()
#+end_src
The temporal mesh is shown by red crosses on the path in the spatial
domain in the left panel of the Figure below and by black dots on the
time axis in the right panel.
#+html: <p align="center"><img src="/R/animations/temporal_mesh.svg" /></p>


*** Matrices of basis function evaluations

**** Matrix of basis function evaluations for positional data
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes

Atilde <- inla.mesh.projector(mesh1d, loc=T.data)$proj$A
Aosc   <- inla.mesh.projector(mesh, loc=coords.trap)$proj$A
Ahd    <- inla.mesh.projector(mesh.hd, loc=HD.data)$proj$A
A      <- inla.row.kron(Ahd, Aosc)
#+end_src


**** Matrix of basis function evaluations for observed firing events
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
Atildeobs <- inla.spde.make.A(mesh=mesh1d, data$Y$firing_times)
Aosc.obs  <- inla.spde.make.A(mesh=mesh, loc=as.matrix(data$Y %>% dplyr:: select(position_x, position_y)))
Ahd.obs   <- inla.spde.make.A(mesh=mesh.hd, data$Y$hd)
Aobs      <- inla.row.kron(Ahd.obs, Aosc.obs)
#+end_src
