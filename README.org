* Repository for R code associated with manuscript on statistical analysis of spike trains from grid cells using Poisson points process models
#+html: <p align="center"><img src="/R/animations/anim_space_direction.varying.direction.combined.gif" /></p>
** Brief code instructions
- load_data.R (do not print any object from this script in the console)
- spde.osc.temporal is the main script for manipulating data and
  fiting models M0, M1 and M2. Models M0 and M1 may be fit
  "reasonably" fast on a standard computer. Model M2 is
  computationally intensive.
- predictions_M0.M1.M2.R contains code for plotting fitted intensity functions for models M0, M1 and M2

** An illustrative example

*** Construction of spatial and circular mesh 
Load packages and helper functions, and set default options for optimization with =INLA=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  library(tidyverse)
  library(dplyr)
  library(purrr)
  library(sp)
  library(INLA)
  library(inlabru)
  bru_options_set(inla.mode = "experimental")
  ## option "experimental" implements Variational Bayes correction this
  ## is useful for Poisson point process likelihoods.
  ## This option is implemented in latest INLA testing version
  if(inla.pardiso.check() != "SUCCESS: PARDISO IS INSTALLED AND WORKING"){
    ## enable openmp for parallel computing using strategy "huge".
    ## this is going to engage all RAM and core resources of the
    ## computer needs some care when setting this up on Eddie.
    bru_options_set(control.compute = list(openmp.strategy="huge"))
  }else{
    bru_options_set(control.compute = list(openmp.strategy="pardiso"))
  }
  source("R/Functions.R")
#+end_src
We load the raw data (session id =M14_2018-05-16_11-29-05=, gridness score 0.913)
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  load(url("https://www.maths.ed.ac.uk/~ipapasta/mouse_data.RData"))
  ls()
#+end_src
The firing events are stored in data frame =Y= and the positional data in data frame =X=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  ##
  ## Firing events and trajectory 
  ## 
  mycoords       <- SpatialPoints(cbind(Y$position_x, Y$position_y))
  Pl   <- Polygon(cbind(X$position_x, X$position_y)); ID   <- "[0,1]x[0,1]"
  Pls  <- Polygons(list(Pl), ID=ID); SPls <- SpatialPolygons(list(Pls))
  df   <- data.frame(value=1, row.names=ID)
  trajectory <- SpatialPolygonsDataFrame(SPls, df)
  ## 
  plot(trajectory)
  points(mycoords, col=2, pch=16, cex=0.5)
#+end_src

 #+begin_src R :results output latex :exports none :session *R:grid_fields* 
   ## svglite(file="R/animations/trajectory.svg", bg="transparent")
   svglite(file="R/animations/trajectory.svg", bg="white")
   ## 
   plot(trajectory)
   points(mycoords, col=2, pch=16, cex=0.5)
   dev.off()
#+end_src

#+html: <p align="center"><img src="/R/animations/trajectory.svg" /></p>
Next we create a spatial and and a circular mesh. The parameter =k= in
the code below controls the resolution of the spatial mesh. Smaller
values for =k= yield finer spatial meshes. The spatial mesh is
constructed in such a way that the resolution is finer for regions
where we observe more spikes and coarser otherwise. Also, since
oscillating Gaussian random fields exhibit strong resonance effects,
it is important to triangulate the domain outside the arena where the
animal runs. The properties of the mesh in the region that is exterior
to the arena can be taken to coarser. For the circular mesh, we choose
a regular grid of of 29 vertices on the circle (the 30th is folded in
the 1st due to cyclicity in the construction below, see =mesh.hd$n=).
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
k           <- 5
mesh        <- inla.mesh.2d(loc=mycoords, max.edge=c(k, 25*k), offset=c(0.03, 120), cutoff=k/2)
p           <- mesh$n
p.theta     <- 30
theta.nodes <- seq(0, 2*pi, len=p.theta)
mesh.hd     <- inla.mesh.1d(theta.nodes, boundary="cyclic", degree=1)
#+end_src
We plot the spatial and circular meshes obtained from the code
above.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  plot(mesh, asp=1)
  x1 <- cos(mesh.hd$loc); y1 <- sin(mesh.hd$loc)
  plot(x1, y1, pch=16, asp=1, axes=FALSE, xlab="", ylab="", main="circular mesh")
  abline(h=0);  abline(v=0)
  text(-.05,1, paste("1")); text(1,-.05, paste("1"))
#+end_src
The constructions of the latent spatial and latent head-directional
effects are tightly linked to the design of the meshes. See Section (REF)

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  ## svglite(file="R/animations/trajectory.svg", bg="transparent")
  svglite(file="R/animations/meshes.svg", bg="white")
  ##
  par(mfrow=c(1,2))
  plot(mesh, asp=1)
  x1 <- cos(mesh.hd$loc); y1 <- sin(mesh.hd$loc)
  plot(x1, y1, pch=16, asp=1, axes=FALSE, xlab="", ylab="", main="circular mesh")
  abline(h=0);  abline(v=0)
  text(-.05,1, paste("1")); text(1,-.1, paste("1"))
  dev.off()
#+end_src
#+html: <p align="center"><img src="/R/animations/meshes.svg" /></p>


*** Boxing line segments
To facilitate a stable numerical integration for the integral in the
Poisson point process likelihood, all line segments from the
trajectory need to be further splitted so that each segment falls
precisely
- in one and only one triangle of the spatial mesh and;
- in one and only one arc out of the possible 29 arcs of the circular
  mesh.

The code below splits first the line segments of the trajectory so
that each line is boxed an arc. When a line is broken, the spatial
coordinates, head direction and time are linearly interpolated

#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
        Ypos.tmp <- data.frame(
          hd=X$hd, time=X$synced_time,
          coords=I(lapply(as.list(apply(cbind(X$position_x, X$position_y),1, as.list)), unlist))) %>%
          mutate(coords.lead = lead(coords)) %>%
          mutate(time.lead = lead(X$synced_time)) %>%
          mutate(hd.lead = lead(X$hd)) %>%
          head(-1)  %>% mutate(HD.split = map2(hd, hd.lead, function(x, y) split.arcs(x,y, mesh.hd=mesh.hd)),
                               L.arcs = lapply(HD.split,
                                               function(x) apply(x, 1,
                                                                 function(y) abs(y[2]-y[1]))),
                               time.split = pmap(list(time, time.lead, L.arcs), function(x,y,z){
                                 o <- interpolate(x,y,z)
                                 oo <- c(attr(o, "data"), y)
                                 ooo <- head(cbind(oo, lead(oo)), -1)
                                 colnames(ooo) <- NULL
                                 return(ooo)
                               }),
                               coords.split=pmap(list(coords, coords.lead, L.arcs), function(x,y,z){
                                 interpolate2(x, y, z)
                               }),
                               new.time = lapply(time.split, function(x) x[,1, drop=FALSE]),
                               new.time.lead= lapply(time.split, function(x) x[,2, drop=FALSE]),
                               new.hd = lapply(HD.split, function(x) x[,1, drop=FALSE]),
                               new.hd.lead = lapply(HD.split, function(x) x[,2, drop=FALSE]),
                               new.coords = lapply(coords.split, function(x) x[,1:2, drop=FALSE]),
                               new.coords.lead = lapply(coords.split, function(x) x[,3:4, drop=FALSE])
                               ) %>% dplyr::select(new.time, new.time.lead, new.hd, new.hd.lead, new.coords, new.coords.lead)%>%
          unnest(cols=c(new.time, new.time.lead, new.hd, new.hd.lead, new.coords, new.coords.lead))
        names(Ypos.tmp) <- c("time", "time.lead", "hd", "hd.lead", "coords", "coords.lead")
#+end_src
Next, the line segments are further split below so that each segment falls in precisely one triangle 
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  line.segments <- split.lines(mesh, sp=Ypos.tmp$coords,
                               filter.zero.length=FALSE,
                               ep=Ypos.tmp$coords.lead, tol=.0)


  df <- data.frame(origin=line.segments$split.origin,
                   filter.index=line.segments$filter.index,
                   sp=I(lapply(as.list(apply(line.segments$sp, 1, as.list)), unlist)),
                   ep=I(lapply(as.list(apply(line.segments$ep, 1, as.list)), unlist))) %>%
    group_by(origin) %>%
    summarize(sp=list(sp), ep=list(ep), filter.index=list(filter.index)) %>%
    mutate(sp = lapply(sp, function(x) do.call("rbind", x))) %>%
    mutate(ep = lapply(ep, function(x) do.call("rbind", x))) 


  ## attribute named _data_ stores length of line segments, time differences and arclengths
  Ypos <- inner_join(Ypos.tmp %>%
                     mutate(origin=1:nrow(Ypos.tmp)), df) %>%    
    mutate(Li = map2(sp, ep,
                     function(x, y) apply(y-x, 1, function(z) sqrt(sum(z^2))))) %>%  
    mutate(Ti = pmap(list(time, time.lead, Li), interpolate)) %>%
    mutate(HDi = pmap(list(hd, hd.lead, Li), interpolate )) 

  filter.index  <- do.call("c", Ypos$filter.index)
#+end_src

