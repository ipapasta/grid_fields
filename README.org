* Hierarchical Poisson point process models for grid cells 
#+html: <p align="center"><img src="/R/animations/anim_space_direction.varying.direction.combined.gif" /></p>
** Brief code instructions
- load_data.R (do not print any object from this script in the console)
- spde.osc.temporal is the main script for manipulating data and
  fiting models M0, M1 and M2. Models M0 and M1 may be fit
  "reasonably" fast on a standard computer. Model M2 is
  computationally intensive.
- predictions_M0.M1.M2.R contains code for plotting fitted intensity functions for models M0, M1 and M2

** An illustrative example

*** Loading data
Load packages and helper functions, and set default options for optimization with =INLA=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  library(tidyverse)
  library(dplyr)
  library(purrr)
  library(sp)
  library(INLA)
  library(inlabru)
  bru_options_set(inla.mode = "experimental")
  ## option "experimental" implements Variational Bayes correction this
  ## is useful for Poisson point process likelihoods.
  ## This option is implemented in latest INLA testing version
  if(inla.pardiso.check() != "SUCCESS: PARDISO IS INSTALLED AND WORKING"){
    ## enable openmp for parallel computing using strategy "huge".
    ## this is going to engage all RAM and core resources of the
    ## computer needs some care when setting this up on Eddie.
    bru_options_set(control.compute = list(openmp.strategy="huge"))
  }else{
    bru_options_set(control.compute = list(openmp.strategy="pardiso"))
  }
  source("R/Functions.R")
#+end_src
We load the raw data (session id =M14_2018-05-16_11-29-05=, gridness score 0.913)
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  load(url("https://www.maths.ed.ac.uk/~ipapasta/mouse_data.RData"))
  ls()
#+end_src
The firing events are stored in data frame =Y= and the positional data in data frame =X=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  ##
  ## Firing events and trajectory 
  ## 
  mycoords     <- SpatialPoints(Y[,c("position_x", "position_y")])
  Pl           <- Polygon(cbind(X$position_x, X$position_y)); ID   <- "[0,1]x[0,1]"
  Pls          <- Polygons(list(Pl), ID=ID); SPls <- SpatialPolygons(list(Pls))
  trajectory   <- SpatialPolygonsDataFrame(SPls, data.frame(value=1, row.names=ID))
  ## 
#+end_src

#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  plot(trajectory)
  points(mycoords, col=2, pch=16, cex=0.5)
#+end_src

 #+begin_src R :results output latex :exports none :session *R:grid_fields* 
   ## svglite(file="R/animations/trajectory.svg", bg="transparent")
   svglite(file="R/animations/trajectory.svg", bg="white")
   ## 
   plot(trajectory)
   points(mycoords, col=2, pch=16, cex=0.5)
   dev.off()
#+end_src
#+html: <p align="center"><img src="/R/animations/trajectory.svg" /></p>

*** Spatial and circular meshes
Next we create a spatial and and a circular mesh. The parameter =k= in
the code below controls the resolution of the spatial mesh. Smaller
values for =k= yield finer spatial meshes. The spatial mesh is
constructed in such a way that the resolution is finer for regions
where we observe more spikes and coarser otherwise. Also, since
oscillating Gaussian random fields exhibit strong resonance effects,
it is important to triangulate the domain outside the arena where the
animal runs. The properties of the mesh in the region that is exterior
to the arena can be taken to coarser. For the circular mesh, we choose
a regular grid of of 29 vertices on the circle (the 30th is folded in
the 1st due to cyclicity in the construction below, see =mesh.hd$n=).
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
k           <- 5
mesh        <- inla.mesh.2d(loc=mycoords, max.edge=c(k, 25*k), offset=c(0.03, 120), cutoff=k/2)
p           <- mesh$n
p.theta     <- 30
theta.nodes <- seq(0, 2*pi, len=p.theta)
mesh.hd     <- inla.mesh.1d(theta.nodes, boundary="cyclic", degree=1)
#+end_src
We plot the spatial and circular meshes obtained from the code
above.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  plot(mesh, asp=1)
  x1 <- cos(mesh.hd$loc); y1 <- sin(mesh.hd$loc)
  plot(x1, y1, pch=16, asp=1, axes=FALSE, xlab="", ylab="", main="circular mesh")
  abline(h=0);  abline(v=0)
  text(-.05,1, paste("1")); text(1,-.05, paste("1"))
#+end_src
The constructions of the latent spatial and latent head-directional
effects are tightly linked to the design of the meshes. See Section (REF)

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  ## svglite(file="R/animations/trajectory.svg", bg="transparent")
  svglite(file="R/animations/meshes.svg", bg="white")
  ##
  par(mfrow=c(1,2))
  plot(mesh, asp=1)
  x1 <- cos(mesh.hd$loc); y1 <- sin(mesh.hd$loc)
  plot(x1, y1, pch=16, asp=1, axes=FALSE, xlab="", ylab="", main="circular mesh")
  abline(h=0);  abline(v=0)
  text(-.05,1, paste("1")); text(1,-.1, paste("1"))
  dev.off()
#+end_src
#+html: <p align="center"><img src="/R/animations/meshes.svg" /></p>


*** Boxing line segments
To facilitate a stable numerical integration for the integral in the
Poisson point process likelihood, all line segments from the
trajectory need to be further split so that each segment falls
precisely
- in one and only one triangle of the spatial mesh and;
- in one and only one arc out of the possible 29 arcs of the circular
  mesh.

The code below uses the wrapper function
=split.segments.wrapper.function=. Firstly, this function uses
=split.arcs= to split the path segments so that each new segment is
boxed by an arc on the circular mesh. Then, the function
=inlabru::split_lines= is used to split again the segments obtained
from of =split.arcs= so that every line segment is also boxed by a triangle. 
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  Ypos.ls        <- split.segments.wrapper.function(X=X, mesh=mesh, mesh.hd=mesh.hd)
  Ypos           <- Ypos.tmp.ls$Ypos
  filter.index   <- Ypos.tmp.ls$filter.index
  line.segments  <- Ypos.ls$line.segments
#+end_src
This output is stored in =Ypos= and the plots below illustrate the
effect of line splitting. The new line segments are plotted over a
subregion of the spatial domain on the left panel below. Each newly
derived line segment is given by the start and end of an arrow whilst
the raw segments by contiguous blue dots. Similarly for the head
direction on the right panel below, each newly derived line segment is
given by contiguous black circles whilst the raw segments by blue
dots. If an line segment was initially boxed by a triangle and by an
arc segment, then this line segment remains unchanged. When there is a
split, however, the values of the covariate (location, head direction
and time) are imputed with linear interpolation.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  par(mfrow=c(1,2))
  plot(mesh, xlim=c(46, 54), ylim=c(46,54), asp=1, main="")
  arrows(do.call("rbind", Ypos$sp)[,1], do.call("rbind", Ypos$sp)[,2], 
         do.call("rbind", Ypos$ep)[,1], do.call("rbind", Ypos$ep)[,2], col=2, lwd=1, length=0.05)
  points(X$position_x, X$position_y, col="blue", pch=16, cex=0.5)
  plot(Ypos$time[1:50,], Ypos$hd[1:50], type="b", cex=1, xlab="time", ylab="head direction")
  points(X$synced_time, X$hd, col="blue", cex=0.5, pch=16)
  abline(h = seq(0, 2*pi, len=30), lty=2, lwd=.5)
#+end_src

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  svglite(file="R/animations/line_splits.svg", bg="white")
  par(mfrow=c(1,2))
  plot(mesh, xlim=c(46, 54), ylim=c(46,54), asp=1, main="")
  arrows(do.call("rbind", Ypos$sp)[,1], do.call("rbind", Ypos$sp)[,2], 
         do.call("rbind", Ypos$ep)[,1], do.call("rbind", Ypos$ep)[,2], col=2, lwd=1, length=0.05)
  points(X$position_x, X$position_y, col="blue", pch=16, cex=0.5)
  plot(Ypos$time[1:50,], Ypos$hd[1:50], type="b", cex=1, xlab="time", ylab="head direction")
  points(X$synced_time, X$hd, col="blue", cex=0.5, pch=16)
  abline(h = seq(0, 2*pi, len=30), lty=2, lwd=.5)
  dev.off()
#+end_src
#+html: <p align="center"><img src="/R/animations/line_splits.svg" /></p>
Lastly, we save the covariate in objects =coords.trap=, =HD.data= and =T.data=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
coords.trap  <- rbind(do.call("rbind",Ypos$sp)[filter.index,], tail(do.call("rbind",Ypos$ep),1))
HD.data      <- c(do.call("c", (Ypos %>% mutate(HD=lapply(HDi, function(x) attr(x, "data"))))$HD), tail(Ypos$hd.lead, 1))
T.data       <- c(do.call("c", (Ypos %>% mutate(T=lapply(Ti, function(x) attr(x, "data"))))$T), tail(Ypos$time.lead, 1))
#+end_src

*** Temporal mesh
Additionally to the spatial and circular meshes, a temporal mesh is
also required when the effect of time on the variation of spikes is
included in models. The temporal mesh is constructed by thinning the
grid of times that are obtained from the newly derived line
segments. Below we choose the fixed value =100= for thinning so that,
if the consecutive times at the starting positions of the line segment
(obtained via splitting) are denoted by =t[1],t[2], ..=, then the
temporal mesh is taken as =t[1],t[300],t[600] ..=. With this
construction, each line segment is also boxed by contiguous time
points in the temporal mesh.
#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  coords.trap  <- rbind(do.call("rbind",Ypos$sp)[filter.index,], tail(do.call("rbind",Ypos$ep),1))
  HD.data      <- c(do.call("c", (Ypos %>% mutate(HD=lapply(HDi, function(x) attr(x, "data"))))$HD), tail(Ypos$hd.lead, 1))
  T.data       <- c(do.call("c", (Ypos %>% mutate(T=lapply(Ti, function(x) attr(x, "data"))))$T), tail(Ypos$time.lead, 1))
  mesh1d  <- inla.mesh.1d(loc=c(T.data[seq(1, length(T.data), by = 300)], T.data[length(T.data)]), order=2)
#+end_src

#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  par(mfrow=c(1,2))
  plot(trajectory)
  points(coords.trap[seq(1, length(T.data), by = 300), 1], coords.trap[seq(1, length(T.data), by = 300), 2], pch=4, col=2, cex=.8, asp=1)
  plot(mesh1d$loc[1:50], rep(0,50), pch=16, cex=0.6, xlab="time", ylab="", axes=FALSE); axis(1)
  abline(h=0)
#+end_src

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  svglite(file="R/animations/temporal_mesh.svg", bg="white")
  par(mfrow=c(1,2))
  plot(trajectory)
  points(coords.trap[seq(1, length(T.data), by = 300), 1], coords.trap[seq(1, length(T.data), by = 300), 2], pch=4, col=2, cex=.8, asp=1)
  plot(mesh1d$loc[1:50], rep(0,50), pch=16, cex=0.6, xlab="time", ylab="", axes=FALSE); axis(1)
  abline(h=0)
  dev.off()
#+end_src
The temporal mesh is shown by red crosses on the path in the spatial
domain in the left panel of the Figure below and by black dots on the
time axis in the right panel.
#+html: <p align="center"><img src="/R/animations/temporal_mesh.svg" /></p>


*** Matrices of basis function evaluations

**** Matrix of basis function evaluations for positional data
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  Aosc   <- inla.mesh.projector(mesh, loc=coords.trap)$proj$A
  Ahd    <- inla.mesh.projector(mesh.hd, loc=HD.data)$proj$A
  A      <- inla.row.kron(Ahd, Aosc)
  Atilde <- inla.mesh.projector(mesh1d, loc=T.data)$proj$A
#+end_src


**** Matrix of basis function evaluations for observed firing events
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  Aosc.obs  <- inla.spde.make.A(mesh=mesh, loc=as.matrix(data$Y %>% dplyr:: select(position_x, position_y)))
  Ahd.obs   <- inla.spde.make.A(mesh=mesh.hd, data$Y$hd)
  Aobs      <- inla.row.kron(Ahd.obs, Aosc.obs)
  Atildeobs <- inla.spde.make.A(mesh=mesh1d, data$Y$firing_times)
#+end_src

**** Illustration of =Aosc=, =A= and =Atilde= matrices
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  par(mfrow=c(1,3))
  image(Aosc, lwd=2, asp=1)
  image(A, lwd=2, asp=1)
  image(Atilde, lwd=2, asp=1)
#+end_src

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  svglite(file="R/animations/temporal_mesh.svg", bg="white")
  par(mfrow=c(1,2))
  plot(trajectory)
  points(coords.trap[seq(1, length(T.data), by = 300), 1], coords.trap[seq(1, length(T.data), by = 300), 2], pch=4, col=2, cex=.8, asp=1)
  plot(mesh1d$loc[1:50], rep(0,50), pch=16, cex=0.6, xlab="time", ylab="", axes=FALSE); axis(1)
  abline(h=0)
  dev.off()
#+end_src


*** Computing integration weights
Firstly, for each line segment of the path, we need to know how much
distance was traveled and how much time it took for the animal to
traverse the segment. 
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  dGamma <- c(do.call("c", Ypos$Li))
  dT  <- diff(T.data)
#+end_src

Secondly, to compute the integration weights, we need to store all
basis function evaluations (i.e., spatial, spatial-directional and
temporal basis functions) at starting points of each line segment of
the path. 
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  ## spatial
  Aosctmp      <- as(Aosc, "dgTMatrix")
  Aosc.indices <- cbind(cbind(Aosctmp@i+1, Aosctmp@j+1), Aosctmp@x) # (i,j, A[i,j]) for which A[i,j] is non-zero (Omega x Theta)
  Aosc.indices <- Aosc.indices[order(Aosc.indices[,1]),] %>% as.data.frame #
  ## spatial-directional
  Atmp         <- as(A, "dgTMatrix")
  A.indices    <- cbind(cbind(Atmp@i+1, Atmp@j+1), Atmp@x) # (i,j, A[i,j]) for which A[i,j] is non-zero (Omega x Theta)
  A.indices    <- A.indices[order(A.indices[,1]),] %>% as.data.frame #
  ## temporal
  Attmp        <- as(Atilde, "dgTMatrix")
  At.indices   <- cbind(cbind(Attmp@i+1, Attmp@j+1), Attmp@x) # (i,j, A[i,j]) for which Atilde[i,j] is non-zero (Time)
  At.indices   <- At.indices[order(At.indices[,1]),] %>% as.data.frame
  ## 
  names(Aosc.indices) <- c("tk", "i", "psi.o") #ot: omega 
  names(A.indices)    <- c("tk", "i", "psi.ot") #ot: omega x theta
  names(At.indices)   <- c("tk", "l", "psi.t")
#+end_src
=A.indices= and =At.indices=: first column is renamed to =tk= which
stands for the index of the line/time/arc segment. For example, for
the spatio-directional basis functions, each =tk= appears 6 times,
i.e., =length(A.indices[,1])/6 = N=, where =N= is the number of
line/time/arc segments. In =A.indices= the second column is renamed to
=i= which stands for the index of the spatio-directional basis
function. In =At.indices= the second row is renamed to =l= which
stands for the index of the temporal basis function

We check =dim(A)[1] == dim(Atilde)[1]= is =TRUE=, both matrices are
basis function evaluations at the starting coordinates and head
directions (=A=) and the starting times (=Atilde=) of the line
segments, that is, each row stores basis function evaluations for a
line. For example, for the matrix of spatio-directional basis
functions, for each starting point of a line segment, there are 6
spatio-temporal basis functions that give a non-zero contribution,
that is 3 knots of a triangle * 2 knots of an arc whilst for the
matrix of temporal basis function, there are 2 temporal basis
functions that give non-zero contributions, that is, 2 time interval
knots.

Below we use helper functions to compute quantities that are necessary
for the integration weights. For example, the helper function
=df.prism.M1.M2.wrapper= used to get df.prism.M1_M2 first groups
=At.indices= and =A.indices= by line segment and then nests them so
each row of the nested data frame contains all basis function
evaluation data a each line segment.  During nesting, information on
the index of the basis functions and its associated value is stored in
new column variables named as =data.x= for the temporal basis
functions, and as =data.y= for the spatio.directional basis functions.
Then information on times, head directions, and coordinates is
appended to the nested data frame, that is, for every line segment
(indexed by variable =tk=), information about the coordinate, the time
and the head direction is appended. Information on lags and leads is
also included because these are subsequently used to get the weights
for the numerical integration scheme based on the trapezoidal
rule. For the computation of the weights, the lengths of the line
segments (=dGamma=) together with their lags and leads are also
appended.  Finally, for the code in the last column variable named
=val=. Fix a line segment, say the first one =tk=1=.  Then, for
example, the first elements of the column variables =data.x= and
=data.y= (these are lists due to the nest operation) are:

## 
## > data.y[[1]]
## # A tibble: 6 x 2
##       i psi.ot
##   <dbl>  <dbl>
## 1  7660 0.0475
## 2  7726 0.405 
## 3  8037 0.246 
## 4  8932 0.0205
## 5  8998 0.175 
## 6  9309 0.106
## 
## > data.x[[1]]
##       l psi.t
##   <dbl> <dbl>
## 1     1     1
## 2     2     0
##

# The following code creates the Cartesian product {1,2} X {7660, 7726,
# 8037, 8932, 8998, 9309}, that is, the set of all ordered pairs (a,b)
# where a \in {1,2} and b \in {7660, 7726, 8037, 8932, 8998, 9309} with
# expand.grid, and calculates, for each pair, the product of the basis
# functions \psi_{T} * \psi_{Omega x Theta} Lastly, the function returns
# a data.frame that has the index of the temporal basis function l, the
# index of the spatio-directional basis function i, and the product of
# the basis functions _val_ this data framed is stored in the column
# variable named val. The final commands discard data.x and data.y which
# are no longer used and unnest the data frame to bring it back to
# standard form



#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
df.prism.M0    <- df.prism.M0.wrapper(Aosc.indices = Aosc.indices, dGamma=dGamma, T.data=T.data, HD.data=HD.data,
                                      coords.trap=coords.trap) %>% unnest(cols=c(val.M0))
df.prism.M1_M2 <- df.prism.M1.M2.wrapper(At.indices= At.indices, A.indices=A.indices, dGamma=dGamma, T.data=T.data, HD.data=HD.data, coords.trap=coords.trap)
df.prism.M1    <- df.prism.M1_M2 %>% dplyr::select(-val.M2) %>% unnest(cols=c(val.M1))
df.prism.M2    <- df.prism.M1_M2 %>% dplyr::select(-val.M1) %>% unnest(cols=c(val.M2))
#+end_src 
