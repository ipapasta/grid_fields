* Repository for R code associated with manuscript on statistical analysis of spike trains from grid cells using Poisson points process models
#+html: <p align="center"><img src="/R/animations/anim_space_direction.varying.direction.combined.gif" /></p>
** Brief code instructions
- load_data.R (do not print any object from this script in the console)
- spde.osc.temporal is the main script for manipulating data and
  fiting models M0, M1 and M2. Models M0 and M1 may be fit
  "reasonably" fast on a standard computer. Model M2 is
  computationally intensive.
- predictions_M0.M1.M2.R contains code for plotting fitted intensity functions for models M0, M1 and M2

** An illustrative example

*** Data formatting
Load packages and helper functions, and set default options for optimization with =INLA=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  library(tidyverse)
  library(dplyr)
  library(purrr)
  library(sp)
  library(INLA)
  library(inlabru)
  bru_options_set(inla.mode = "experimental")
  ## option "experimental" implements Variational Bayes correction this
  ## is useful for Poisson point process likelihoods.
  ## This option is implemented in latest INLA testing version
  if(inla.pardiso.check() != "SUCCESS: PARDISO IS INSTALLED AND WORKING"){
    ## enable openmp for parallel computing using strategy "huge".
    ## this is going to engage all RAM and core resources of the
    ## computer needs some care when setting this up on Eddie.
    bru_options_set(control.compute = list(openmp.strategy="huge"))
  }else{
    bru_options_set(control.compute = list(openmp.strategy="pardiso"))
  }
  source("R/Functions.R")
#+end_src
We load the raw data (session id =M14_2018-05-16_11-29-05=, gridness score 0.913)
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  load(url("https://www.maths.ed.ac.uk/~ipapasta/mouse_data.RData"))
  ls()
#+end_src
The firing events are stored in data frame =Y= and the positional data in data frame =X=.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  ##
  ## Firing events and trajectory 
  ## 
  mycoords       <- SpatialPoints(cbind(Y$position_x, Y$position_y))
  Pl   <- Polygon(cbind(X$position_x, X$position_y)); ID   <- "[0,1]x[0,1]"
  Pls  <- Polygons(list(Pl), ID=ID); SPls <- SpatialPolygons(list(Pls))
  df   <- data.frame(value=1, row.names=ID)
  trajectory <- SpatialPolygonsDataFrame(SPls, df)
  ## 
  plot(trajectory)
  points(mycoords, col=2, pch=16, cex=0.5)
#+end_src

 #+begin_src R :results output latex :exports none :session *R:grid_fields* 
   ## svglite(file="R/animations/trajectory.svg", bg="transparent")
   svglite(file="R/animations/trajectory.svg", bg="white")
   ## 
   plot(trajectory)
   points(mycoords, col=2, pch=16, cex=0.5)
   dev.off()
#+end_src


#+html: <p align="center"><img src="/R/animations/trajectory.svg" /></p>
Next we create a spatial and and a circular mesh. The parameter =k= in
the code below controls the resolution of the spatial mesh. The
spatial mesh is constructed in such a way that the resolution is finer
for regions where we observe more spikes and coarser otherwise. Also,
since oscillating Gaussian random fields exhibit strong resonance
effects, it is important to triangulate the domain outside the arena
where the animal runs. The properties of the mesh in the region that
is exterior to the arean can be taken to coarser. 
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
k           <- 5
mesh        <- inla.mesh.2d(loc=mycoords, max.edge=c(k, 25*k), offset=c(0.03, 120), cutoff=k/2)
p           <- mesh$n
p.theta     <- 30
theta.nodes <- seq(0, 2*pi, len=p.theta)
mesh.hd     <- inla.mesh.1d(theta.nodes, boundary="cyclic", degree=1)
nodes       <- c(mesh.hd$loc, 2*pi)
intervals   <- head(cbind(nodes, lead(nodes)), -1)
#+end_src
We visualize the spatial and circular meshes obtained from the code
above.
#+begin_src R :results output code :exports code :session *R:grid_fields*  :tangle yes
  plot(mesh, asp=1)
  x1 <- cos(mesh.hd$loc); y1 <- sin(mesh.hd$loc)
  plot(x1, y1, pch=16, asp=1, axes=FALSE, xlab="", ylab="", main="circular mesh")
  abline(h=0);  abline(v=0)
  text(-.05,1, paste("1")); text(1,-.05, paste("1"))
#+end_src
The construction of the latent spatial and head-directional is tightly
linked to the construction of the meshes. See Section.. 

#+begin_src R :results output latex :exports none :session *R:grid_fields* 
  ## svglite(file="R/animations/trajectory.svg", bg="transparent")
  svglite(file="R/animations/meshes.svg", bg="white")
  ##
  par(mfrow=c(1,2))
  plot(mesh, asp=1)
  x1 <- cos(mesh.hd$loc); y1 <- sin(mesh.hd$loc)
  plot(x1, y1, pch=16, asp=1, axes=FALSE, xlab="", ylab="", main="circular mesh")
  abline(h=0);  abline(v=0)
  text(-.05,1, paste("1")); text(1,-.05, paste("1"))
  dev.off()
#+end_src
#+html: <p align="center"><img src="/R/animations/meshes.svg" /></p>
